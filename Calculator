;THIS PROGRAM RUN TINY CALCULATOR. 
;TAKES IN ANY 2, 16 BIT NUMBER AND
;PREFORMS AND PERFORMS ADDITION OR 
;SUBRTRACITON. THE RESULT IS
;PRINTED ON TEH THE SCREEN
		
		
		ORG		    100H
BOOT    EQU         0				
BS      EQU         08H
BDOS    EQU         5
CR      EQU         13
LF		EQU		    10 
        LXI         SP, SP0             ;LOAD THE STACK POINTER
		MVI		    C, 9				;MOVE 9 TO C TO PRINT FIRST MESSAGE 
		LXI			D, MESS1
		CALL		BDOS
AGAIN:	LXI 	    D, INTRO			;LOAD MESSAGE FOR THE INTRODUCTION OF THE PROGRAM
		CALL 		BDOS				;PRINT FIRST MESSAGE
		MVI			C,2
		MVI			E,'>'
		CALL		BDOS
		CALL		BDOS
		MVI			C, 1
		LXI			D, 0				;SETNUMBER STORAGE TO 0
		LXI			H, 0
	

REDO:	CALL 		BDOS 				;FIRST NUMBER OF THE ADDITION DUBTRACTION
		CPI			CR
		JZ			FINI				;CHECK IF ENTER WAS CLICKED
		CALL		CHECK				;SET OFF CARRY FLAG IF INPUT IS NOT A NUMBER (FIRST INPUT IS A NUMBER)
		CC			DEL					;DELETE FIRST NUMBER IF ITS NOT THE RIGHT ONE
		JC			REDO				;RETAKE THE VALUE FO THE FIRST NUMBER IF ITS NOT A CORRECT INPUT
		
		SUI			'0'					;GET DECIMAL VALUE IN a
		MOV			L, A				;MOVE FIRST NUMBER INTO CORRECT SPOT
		
ON:		CALL 		BDOS				;TAKE IN NEXT INPUT
		CPI 		'+'					;CHECK IF SIGN USED IS ADDIITON OR SUBTRACTION
		JZ			DONE	
		CPI			'-'
		JZ			DONE
		CALL 		CHECK 				;MAKE SURE ITS A NUMBER
		CC			DEL					;DELETE A CHARACTER IF THE CODE IS NOT A NUMBER
		JC 			ON					;REPEAT IF NUMBER ISNT SET
		CALL		MODIFY				;MULTIPLY BY 10 AND ADD EXTRA BIT
		JMP			ON					;JUMP BACK TO TAKE ANOTHER USER INPUT
		
DONE:	CALL		SIGN				;AFTET PLUS OR MINUS IS CHOSEN STARTS TO TAKE IN TEH NEXT VALUE ADD/SUB=
		CALL 		PRINT				;PRINT OUT THE AMOUNT 
		MVI			C,9
		JMP			AGAIN
		
FINI: 	LXI			D, FINAL
		MVI			C,9
		CALL		BDOS
		JMP			BOOT



;--------------------------------------------------------SUBRROUTINES
		
		
		;TAKES IN USER INPUT AND DEALS WITH ADDITION OR SUBTRACTION
		;INPUT: USER INPUT, HL PAIR
		;OUTPUT: RESULTING ANSWER IN THE HL PAIR
		;NO REG DESTORYED EXCEPT HL PAIR
		;SUBROUTINES USED: OPER, FLIP 
		
SIGN:	PUSH	D
		PUSH 	PSW
		CALL	OPER				;GET PROPER SECONDNUMBER
		CPI 	'-'					;CHECK IF A HAS ADDITION OR SUBRATCITOn
		JNZ		FORW				;JUMP TO ADDITION
		MOV 	A, L				;MOVE LOWER BIT TO ACCUMULATO 
		SUB  	E					;SUBTRACT UPPER BIT WITHOUT A CARRY
		MOV		L, A				;MOVE RESULT BACK TO HL PAIR
		MOV		A, H				;MOVE LEADING BITS TO ACCUMULATOR 
		SBB		D					;SUBTRACT LEADING BITS WITH A BORROW
		MOV		H,A
		CM		FLIP
		JMP 	RETE				;END
FORW:	DAD		D					;ADD THE TWO 16 BIT REGISTERS
RETE:	POP		PSW	
		POP		D
		
		RET
		
		
	
		;THIS SUBROITINE TAKES IN THE VALUE OF THE SECOND NUMBER AFTER THE ADDITIONS PLACE
		;INPUT: TAKE IN THE USER INPUTED VALUE IN DE PAIR
		;OUTPUT: SECOD NUMBER INPUTED PUT IN DE PAIR
		;NO REG DESTROYED EXCEPT D-E PAIR
		;SUBROUTINES USED: CHECK, MODIFY
OPER: 	PUSH 		PSW
		PUSH		B
		PUSH		H
		LXI			H, 0
PLACE:	CALL		BDOS 		;TAKE IN NEXT INPUT FOR AFTER THE SIGN 
		CALL		CHECK
		CC			DEL
		JC 			PLACE		;TAKE IN THE FIRST VALUE WHICH MUST BE NUMBER 
		SUI			'0'
		MOV			L,A
		
PREV:	CALL		BDOS		;TAKE IN NEXT INPUT 
		CPI			'='			;COMPARE TO EQUAL SIGN
		JZ			NEXT		;EXIT OUT OF THERE
		CALL		CHECK
		CC			DEL
		JC			PREV
		CALL		MODIFY		;MULIPLY HL BY 10 AND ADD THE EXTRA BIT IF 
		JMP			PREV
NEXT:	MOV			D,H
		MOV			E,L
		POP			H
		POP			B
		POP			PSW
		RET
		
		
		
		;PRINT: PRINT ALL BITS OF THE RESULT
		;INPUT: HL PAIR
		;OUTPUT; RESULTING ANSWER
		;NO REG DESTORYED
		;SUBROUTINES: PRINT1, 
PRINT: PUSH			B
	   PUSH			D
	   LXI			B, 10000
	   CALL			PRINT1
	   LXI			B, 1000
	   CALL			PRINT1
	   LXI			B, 100
	   CALL			PRINT1
	   LXI			B, 10
	   CALL			PRINT1
	   MOV 			A, L		
	   ADI			'0'			;CONVERT LAST BIT TO ASCII
	   MOV 			E, A
	   MVI			C,2
	   CALL			BDOS
	   POP			D
	   POP			B
	   RET
	
	
	
	
		;PRINT1: PRINTS MOST SIGNIFICANT PIT
		;H-L PAIR VALUE, B-C PAIR = WEIGHT OF DEC PLACE
		;OUTPUT: PRINTS MOST SIGNIFICANT BIT
		;REG DESTROYED: NONE EXCEPT H-L PAIR
		;SUBROUTINES USED: NONE
PRINT1: PUSH	B
		PUSH	D
		PUSH	PSW
		MVI		E, '0'
REPL:	MOV 	A, L
		SUB		C
		MOV 	L,A
		MOV		A,H
		SBB		B
		MOV		H,A
		JC		GO
		INR		E
		JMP		REPL
GO:		DAD		B
		MVI 	C,2
		CALL	BDOS
		POP		PSW
		POP		D
		POP		B
		RET
		
		
		
		

		;FLIPS ALL THE BITS IN THE GIVEN REGISTER
		;INPUT; VALUE OF HL PAIR 
		;OUTPUT: FLIPPED BIT VERSION OF HL PAIR
		;NO REG DESTROYED EXCEPT HL
		;SUBROUTINES USED: 
FLIP:	PUSH 	B
		PUSH	PSW
		PUSH	D
		MVI		C,2
		MVI 	E, '-'
		CALL	BDOS
		MOV		A,H			;MOVE H TO A
		CMA					;FLIP ALL BITS IN H
		MOV		H,A			;MOVE H BACK
		MOV		A,L			;MOVE LOWER BITS TO ACCUM
		CMA					;FLIP ALL BITS
		MOV		L,A			
		MVI		B,0			;CLEAR B-C PAIR
		MVI		C,1	
		DAD		B			;ADD ONE TO GET 2 BIT COMPLIMENT
		POP		D
		POP		PSW
		POP		B
		RET




		
		;DELETES A PRINTED CARATERS
		;INPUT; NOTHING
		;OUTPUT/ACTION: DELETE SPACE
		;SUBROUTINE USED: NONE 
		
DEL: 	PUSH		B
		PUSH 		D			
		MVI 		C, 2		;PUT 2 INTO C TO PRINT 
		MVI 		E, BS		;BACK SPACE 
		CALL 		BDOS	
		MVI 		E,' '		;PRINT SPACE 
		CALL 		BDOS
		MVI			E, BS		;BACKSPACE 
		CALL 		BDOS
		POP 		D
		POP			B
		RET
		
	
	
	
	;CHEKKS IF NUMBER IS FORM 0 - 9
		;INPUT: A REG
		;SETS OR DOESNT SET CARRY 
		;NO REGISTER DESTORYED
		;SUBROUTINE USED:NONE

		
CHECK: 	CPI 		'0'			;CHECK IF GREATER THAT 0
		RC							
		CPI			'9' + 1		;CHECK UPPER LIMIT
		CMC
		RET
		
		;MODIFY: MULIPLYES H-L PAIR BY 1O AND ADDS USEER INPUT IN A TO H-L PAIR
		;INPUT, HL PAIR, VALUE IN A
		;OUTPUT: MODIFIED VALUE IN HL PAIR
		;NO REG DESTORYED (EXCEPT HL)
		;SUBROUTINE USED: NONE
		
MODIFY:	PUSH		D
		PUSH		B
		PUSH		PSW
		LXI			B, 0
		DAD			H
		PUSH		H
		DAD			H
		DAD			H
		POP			D
		DAD			D
		SUI			'0'			;TAKE THE INPUTED VALUE FROM A AND CONVERT FROM ACCII TO DECIMAL
		MOV 		C,A
		DAD			B
		POP			PSW
		POP			B
		POP			D
		RET

;-------------------------------------------------------------------------------------------MEMORY		
			
	
MESS1: 	DB		'TINY CALCULATOR $'								;FIRST MESSAGE
INTRO:	DB		LF,CR,'THIS IS THE TINY CALCULATOR HIT <CR> TO END THIS ',LF,CR, '$'		;MESSAGE REPAEATED
FINAL:	DB		LF,CR,'THANK YOU FOR USING TINY CALCULATOR $'			;FINAL MESSAGE AFTER CARRIAGE RETURN 
		DS		24   			;MAX STACK USED IS 22 ACCORIDNG TO PROGRAM (2 BIT BUFFFER IN CASE)
    SP0		EQU			$	
		END
		
		
		
